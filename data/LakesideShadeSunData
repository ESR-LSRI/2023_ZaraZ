# -*- coding: utf-8 -*-
"""
Created on Wed Jun 14 10:35:43 2017

@authors: Mike.Town, Allistair.Yu, Andy.Stanciu
"""

## PROGRAM NOTE
## PLEASE REFER to README.txt for instructions on how to use this program

## Program to import sunlight/buried and shade iButton data and generate figures

## Note: the program is compatible with gaps in the data, replace any values 
## that you do not wish to graph with -999 (in the csv file).
## Leave the time series as is for this to work.

import os as os # for moving around the operating system
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import UnivariateSpline
from scipy.stats import linregress

##Google Colab, needed for importing files from drive
from google.colab import drive;
print(os.getcwd());
drive.mount("/content/drive");

print("Note: to get sunlight minus shade data, select the shade data as the "
        "first data file and sunlight data as the second data file.");

def getLocalFile(location, name):
    """
    Used to get a local file, useful for testing without prompting user
    for file loacation

    Args:
        location (str): file location
        name (str): file name

    Returns: file data and name
    """
    dataFile = open(location + name, 'r');
    data = dataFile.readlines();
    
    return data, name;

def getFileFromDrive(prompt):
    """
    Used to get a file from Google Drive, the best way to do it with Colaboratory

    Args:
        prompt (str): the customized prompt for the user

    Returns: file data and name
    """
    path = str(input(prompt));
    dataFile = open(path, 'r');
    data = dataFile.readlines();
    name = os.path.basename(path);

    return data, name;

def getFile(prompt):
    """
    Prompts user for data file location and gets data from the selected file
    
    Args:
        prompt (str): the customized prompt for the user
        
    Returns:
        The data as a list and the data file name
    """
    dataFileLocation = input(prompt);
    os.chdir(dataFileLocation);
    dirContents = os.listdir('.');
    dirContents.sort();
    i = 0;
    while i < len(dirContents):
        print(str(i) + '\t' + dirContents[i]);
        i = i + 1;
    dataFileNum = int(input('Enter the number of the data file: '));
    dataFile = open(dirContents[dataFileNum],'r');
    dataFileName = dirContents[dataFileNum][:-4] #get rid of extension
    data = dataFile.readlines();
    dataFile.close();
    return data, dataFileName;

def getiButtonData(data):
    """
    Loops through any temperature iButton data and unpacks time and temperature
    
    Args:
        data (list): the data from the iButton
    
    Returns:
        The time series (in decimal days) and the temperature array.
        Add dateTime or unit return if needed.
    """
    dateTime = [];
    unit = [];
    T = [];
    td = [];
    previous = 0;
    foundAMPM = False;
    for row in data:
        dateTimeTemp, unitTemp, T_Temp = row.split(',');

        try:
            monthDayYear, time_Temp = dateTimeTemp.split(' ');
        except:
            try:
              monthDayYear, time_Temp, AMPM_Temp = dateTimeTemp.split(' ');
              foundAMPM = True;
            except:
              continue;

        month_Temp, day_Temp,year_Temp = monthDayYear.split('/');
        try:
            hour_Temp, minute_Temp = time_Temp.split(':');
        except:
            hour_Temp, minute_Temp, second_Temp = time_Temp.split(':');
        
        #convert the clock to 24hr
        if foundAMPM:
            if AMPM_Temp == 'PM':
                if int(hour_Temp) == 12:
                    hour_Temp = '12';
                else:
                    hour_Temp = str(int(hour_Temp)+12);
            elif int(hour_Temp) == 12: #clock should read 00:00 at midnight
                hour_Temp = '00';
    
        # clean up the strings to be read by np.datetime64
        if int(month_Temp) < 10:
            month_Temp = '0' + month_Temp;
        if int(day_Temp) < 10:
            day_Temp = '0' + day_Temp;
        if (int(hour_Temp) < 10) & (int(hour_Temp) != 0) & (foundAMPM == True):
            hour_Temp = '0' + hour_Temp;
        elif (int(hour_Temp) < 10) & (foundAMPM == False):
            hour_Temp = '0' + hour_Temp;
            
        dateTime.append(dateTimeTemp);
           
        td_Temp = np.datetime64(year_Temp + '-' + month_Temp + '-' + day_Temp \
                    + 'T' + hour_Temp + ':' + minute_Temp) -\
                    np.datetime64(year_Temp + '-01-01T00:00');
        td_Temp = td_Temp / np.timedelta64(1,'s'); # converts this into a
                                                   #decimal seconds value
        td_Temp = td_Temp/86400; # converts this into a decimal day value.
        
        # adjust day in case decimal days reset to 0 at the New Year
        if td_Temp < previous: #(previous = 0)
            td_Temp = td_Temp + 365;        
            td.append(td_Temp);
        else:
            td.append(td_Temp);
        unit.append(unitTemp);
        T.append(float(T_Temp));
        previous = td_Temp;

    return np.asarray(td), np.asarray(T);

def findDayTimes(time, evening, morning, **kwargs):
    """
    Filters out "nighttime" data for several data arrays
    
    Args:
        time (list): time series with which the kwargs must align
        evening (float): decimal threshold for what is considered evening;
            (0.0-1.0); should be greater than morning value
        morning (float): decimal threshold for what is considered morning;
            (0.0-1.0); should be less than evening value
        **kwargs: lists whose day times can be found
            diff: temperature differences
            temps1: temperatures from data1 (must match up with time)
            temps2: temperatures from data2 (must match up with time)
    
    Returns:
        Versions of the arguments/parameters that don't include "nighttime"
        data
    """
    # isolate decimal of each data point to tell if it's morning or evening
    decimal = time - np.asarray([int(i) for i in time])
    notEvening = np.argwhere(decimal < evening)# evening threshold
    notMorning = np.argwhere(decimal > morning)# morning threshold
    day = np.intersect1d(notEvening, notMorning) # where day points are
    dayTimes = []; # list of time values where it's just day
    dayTempDiffs = []; # list of temp diff values where it's just day
    dayT1 = []; # list of temp 1 values where it's just day
    dayT2 = []; # list of temp 2 values where it's just day
    for i in range(len(day)):
        index = day[i];
        dayTimes.append(time[index]); 
        if 'diff' in kwargs:
            dayTempDiffs.append(kwargs.get('diff')[index]);
        if 'temps1' in kwargs:
            dayT1.append(kwargs.get('temps1')[index])
        if 'temps2' in kwargs:
            dayT2.append(kwargs.get('temps2')[index]);
    return dayTimes, dayTempDiffs, dayT1, dayT2;


def findDTR(time, temps):
    """
    Finds diurnal (daily) temperature range (this method is not used right now)
    
    Args:
        time (list): time series of an iButton sensor
        temps (list): temperature values of the same iButton sensor
    
    Returns:
        A list of temperature ranges for each day
    """
    minimum = 0;
    maximum = 0;
    ranges = []; # list of temperature ranges for each day
    oneDay = []; # holds temperature values of each individual day
    i = 0;
    while i < len(time) - 1: #sorts decimal all day values into oneDay lists 
                            #so daily ranges can be found.
                            #doesn't check last data point; fix if possible
        if int(time[i]) == int(time[i+1]):
            oneDay.append(temps[i]);
        else:
            oneDay.append(temps[i])
            minimum = min(oneDay);
            maximum = max(oneDay);
            ranges.append(maximum-minimum);
            del oneDay[:]; # clear oneDay list
        i = i + 1;
    return ranges;

def interpolate(time1, temp1, time2, degree = 3):
    """
    Interpolation stuff (line up temp1 to match up with time2).
    Note: this function should just be used with two iButton data sets. Other
    interpolation can be done with this function, but this is set up
    specifically for two sets of temp/time data.
    
    Args:
        time1 (list): time series from data1
        temp1 (list): temperatures from data1
        time2 (list): time series from data2
        degree (int): degree for polynomial fit, default is 3
    
    Returns:
        Interpolated temp1
    """
    spline = UnivariateSpline(time1, temp1, k = degree);
    interpolated = spline(time2);
    return interpolated;

## GET DATA FILES

input1, dataFileName1 = getFileFromDrive('Enter the case-sensitive location of the iButton data file: ');
input2, dataFileName2 = getFileFromDrive('Enter the case-sensitive location of the second iButton data file: ');
input3, dataFileName3 = getFileFromDrive('Enter the case-sensitive location of the solar radiation data file: ');

#Reads from the start to the end of the Lakeside test csv
data1 = input1[15:len(input1)];
data2 = input2[15:len(input1)];

## Method to scan imported files for -999 and replace them with NaN values
def replaceNaN(data):
    for i in range (len(data)):
        if data[i] == -999:
            data[i] = np.nan;

## Method to get the start and end indices of the data, this is necessary as it
## skips over the NaN segments         
def getStartEnds(data):
    index = 0;
    result = [];
    length = len(data);
    while length > index:
        
        #Searching for first valid element
        while length > index and np.isnan(data[index]):
            index = index + 1;
    
        result.append(index);
        #Searching for the first invalid element
        while length > index and not np.isnan(data[index]):
            index = index + 1;
            
        result.append(index);
       
    return result;

# Extracting only 1/1/2019 to 3/1/2019 from all data sets for solar radiation plot
data1Abridged = input1[105:459];
data2Abridged = input2[105:459];
data3 = input3[83:84804];

def getNewUWData(data):
    ## SPECIFIC TO NEW UW SOLAR RADIATION DATA FILE FORMAT, ADJUST AS NEEDED
    i = 0;
    solarTime = []; #time series for solar radiation data
    solarRad = []; #solar radiation values
    while i < len(data3):
        dateTemp, timeTemp, rad, radError = data[i].split(",");
        hourTemp, minuteTemp = timeTemp.split(":");
        monthTemp, dayTemp, yearTemp = dateTemp.split("/");

        if (len(monthTemp) != 2):
            monthTemp = "0" + monthTemp;
        if (len(dayTemp) != 2):
            dayTemp = "0" + dayTemp;

        if int(hourTemp) < 10: #formatting for datetime
            hourTemp = "0" + hourTemp;

        td_Temp = np.datetime64(yearTemp + "-" + monthTemp + "-" + dayTemp +\
                  'T' + hourTemp + ':' + minuteTemp) -\
                  np.datetime64('2019-01-01T00:00');
        td_Temp = td_Temp / np.timedelta64(1,'s'); # converts this into a decimal
                                                   # seconds value
        td_Temp = td_Temp/86400; # converts this into a decimal day value.    
        td_Temp = td_Temp - .2916666; #subtract 7 hours to convert from GMT to PDT
        
        solarTime.append(td_Temp);

        #radiation data has some formatting errors and spreads to 2 columns
        if rad != "-1":
            solarRad.append(float(rad));
        else:
            solarRad.append(float(radError));
            
        i = i + 240; # data is every 1 minute, so 240 matches iButton logging rate

    return solarTime, solarRad;

## convert hours minutes seconds to days
## https://matplotlib.org/api/dates_api.html

td1, T1 = getiButtonData(data1);
td2, T2 = getiButtonData(data2);

replaceNaN(T1);
replaceNaN(T2);

solarTime, solarRad = getNewUWData(data3);
timeAbridged1, tempAbridged1 = getiButtonData(data1Abridged);
timeAbridged2, tempAbridged2 = getiButtonData(data2Abridged);

replaceNaN(solarRad);
replaceNaN(tempAbridged1);
replaceNaN(tempAbridged2);

startEnds1 = getStartEnds(T1);
startEnds2 = getStartEnds(T2);
startEnds1Abridged = getStartEnds(tempAbridged1);
startEnds2Abridged = getStartEnds(tempAbridged2);
startEndsSR = getStartEnds(solarRad);

if startEnds1 != startEnds2 or startEnds1Abridged != startEnds2Abridged:
    raise Exception("Missing data values are inconsistent between temperature sensors.");

#interpolates only the segments that have no NaN values 
interpolatedT1 = np.zeros(len(T1));
for i in range (len(T1)):
    interpolatedT1[i] = np.nan;
        
for i in range (int(len(startEnds1) / 2)):
    start = startEnds1[i * 2]
    end = startEnds1[i * 2 + 1]
    interpolatedT1[start:end] = interpolate(td1[start:end], T1[start:end], td2[start:end]);
    
interpolatedT1Abridged = np.zeros(len(tempAbridged1));
for i in range (len(tempAbridged1)):
    interpolatedT1Abridged[i] = np.nan;
    
for i in range (int(len(startEnds1Abridged) / 2)):
    start = startEnds1Abridged[i * 2]
    end = startEnds1Abridged[i * 2 + 1]
    interpolatedT1Abridged[start:end] = interpolate(timeAbridged1[start:end],\
                          tempAbridged1[start:end], timeAbridged2[start:end]);
    
                          
# temperature differences  
diff = T2 - interpolatedT1 
abridgedDiff = tempAbridged2 - interpolatedT1Abridged;

dayTimes, dayTempDiffs, dayT1, dayT2 = findDayTimes(td2, .6, .4, diff = diff,\
                                                    temps1 = T1, temps2 = T2)

dayTimesAbridged, dayTempDiffsAbridged, dayT1Abridged, dayT2Abridged = findDayTimes(timeAbridged2, .6, .4, diff = abridgedDiff,\
                                                    temps1 = timeAbridged1, temps2 = timeAbridged2)

daySolarTime, _, daySolarRad, _ = findDayTimes(solarTime, .6, .4,\
                                                    temps1 = solarRad)
noonSolarTime, _, noonSolarRad, _ = findDayTimes(solarTime, .6, .4,\
                                                    temps1 = solarRad)

#converting to np arrays to be able to work with np.nan properties
dayTempDiffs = np.array(dayTempDiffs);
dayTempDiffsAbridged = np.array(dayTempDiffsAbridged);

## PLOT

# Figure 1. iButton temperature vs. time
plt.figure(1)
plt.plot(dayTimes, dayT1, 'ro', label = 'in shade');
plt.plot(dayTimes, dayT2, 'g.', label = 'buried');
plt.ylabel('T ($\degree$C)', fontsize = 18);
plt.xlabel('day of year', fontsize = 18);
xticks = plt.xticks()[0]
plt.xticks(xticks, (xticks % 365)) # makes xticks reset at 0 at day 365

plt.axvline(x=365.25, label = '2019', linestyle = '--');
plt.legend(loc=1, prop={'size': 18});
plt.subplots_adjust(top = 1.5, hspace = 0.2, right = 1.6); #adjust graph size


#Figure 2. Temperature difference histogram
plt.figure(2)
plt.subplots_adjust(top = 1.5, hspace = 0.2, right = 1.6);
plt.hist(diff[~np.isnan(diff)], bins=np.arange(min(diff), max(diff) + 1, 1),\
            color = 'red', alpha = 0.5, label = 'day and night')

plt.hist(dayTempDiffs[~np.isnan(dayTempDiffs)], bins=np.arange(min(diff), max(diff) + 1, 1),\
            label = '12 p.m.');

plt.ylabel('Number', fontsize = 18);
plt.xlabel('$T_{buried} - T_{shade}$ ($\degree$C)', fontsize = 18);
plt.legend(prop = {'size':18});

#Figure 3. Temperature difference vs. daily solar radiation correlation
plt.figure(3);
plt.subplots_adjust(top = 1.5, hspace = 0.2, right = 1.6);
interpolatedSR = interpolate(daySolarTime, daySolarRad, dayTimesAbridged);
plt.plot(dayTempDiffsAbridged, interpolatedSR, 'ro')


#fit trendline
dayTempDiffsStartEnds = getStartEnds(dayTempDiffsAbridged);
dayTempDiffsAbridged = dayTempDiffsAbridged[~np.isnan(dayTempDiffsAbridged)];
interpolatedSRTemp = np.zeros(len(dayTempDiffsAbridged));
for i in range (len(dayTempDiffsAbridged)):
    interpolatedSRTemp[i] = np.nan;

index = 0;
for i in range (int(len(dayTempDiffsStartEnds) / 2)):
    start = dayTempDiffsStartEnds[i * 2]
    end = dayTempDiffsStartEnds[i * 2 + 1]
    interpolatedSRTemp[index:index + end - start] = interpolatedSR[start:end];
    index = index + end - start;

interpolatedSR = interpolatedSRTemp;

slope, intercept, r_value, p_value, std_err = linregress(dayTempDiffsAbridged,\
                                                        interpolatedSR)
r_squared = r_value**2
r_squared = (round(r_squared, 2))

z = np.polyfit(dayTempDiffsAbridged, interpolatedSR, 1)
p = np.poly1d(z)
plt.plot(sorted(dayTempDiffsAbridged), sorted(p(dayTempDiffsAbridged)), 'r--') 

plt.text(-1.5, 550, '$R^2$ = ' + str(r_squared), fontsize = 15)
plt.text(-1.5, 600, '$F_s$ = ' + str(round(slope, 1)) +\
        ' $W$ $˚C^{-1}$ $m^{-2}$ ∆T + ' + str(round(intercept, 1)) +\
        ' $W$ $m^{-2}$', fontsize = 15)
plt.ylabel('daily solar radiation ($W$ $m^{-2}$)', fontsize = 18)
plt.xlabel('$T_{buried} - T_{shade}$ ($\degree$C)', fontsize = 18)
plt.xlim([-2, 14]);
plt.ylim([0, 700]);
